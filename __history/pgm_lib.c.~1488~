/* This file contains all programmer functions */
#include "pgm_lib.h"  
#include <stdlibm.h> //necessary for malloc 

volatile unsigned int8 DATAin[64];  //USB packet is copied here when received 
unsigned int8 i;     //used to iterate through DATAin in Process_Input()

unsigned int8 data_out[64]; //Data is read from here by USB

//unsigned int8 icsp_rate; //period in multiples of 1uS 
unsigned int8 icsp_pins_states; 

unsigned int8 DATA_Out_Buffer[128]; //Data is stored here by scripts and will be copied to data_out to be read by USB
struct 
{
   unsigned int8 rd_idx;
   unsigned int8 wr_idx;
   unsigned int8 nbr_bytes; //number of bytes in DATA_On_Buffer
} DOB_mngnt;   //DATA_Out_Buffer Management

unsigned int8 DATA_In_Buffer[256];
struct 
{
   unsigned int8 rd_idx;
   unsigned int8 wr_idx;
   unsigned int8 nbr_bytes; //number of bytes in DATA_In_Buffer
} DIB_mngnt;   //DATA_In_Buffer Management 

//unsigned int8 scrpt_args[20];
//unsigned int8  scrpt_rd_idx = 0; //scrpt_args_num_bytes = 0,

struct {
   unsigned int8   VddThreshold;   // error detect threshold
   unsigned int8   VppThreshold;   // error detect threshold
    unsigned int8   VddErrCount;
    unsigned int8   VppErrCount;
    unsigned int16    BlinkClount;    // counter for blinking Busy on VDD/VPP error
} VddVppLevels;

struct {
   unsigned int8 CCPRSetPoint;
   unsigned int8 UppperLimit;
   unsigned int8 LowerLimit;   
} Vpp_PWM;

struct {
    unsigned int16    adc_calfactor;      // CalibratedResult = (ADRES * adc_calfactor) >> 8
    signed int8       vdd_offset;
    unsigned int8   vdd_calfactor;      // Calibrated CCP value = (((CCP >> 6) + vdd_offset) * vdd_calfactor) >> 7
} VoltageCalibration; 


void pgm_init()
{
   #ASM
   MOVLW 0x13
   MOVWF HLVDCON           //Configure HIGH/LOW-VOLTAGE DETECT CONTROL REGISTER, See datasheet page 281
   
   BCF HLVDIF          //Clear High/Low-Voltage Detect Interrupt Flag bit, Datasheet page 105
   BSF HLVDIE         //Enable High/Low-Voltage Detect Interrupt, datasheet page 107
   
   //Initialize I/O
   
   BSF TRISA0        // Set pin A0 as input, datasheet page 113
   BSF TRISA1        // Set pin A1 as input
   
   MOVLW 0x0D
   MOVWF ADCON1            // A0 & A1 Set as Analog inputs, DS page 262
   
   MOVLW 0x03
   MOVWF ADCON2            // A/D Conversion Clock Select bits, clock derived from A/D RC oscillator, DS page 263
   
   BSF tris_ICSPDAT        // pin A2 set as input
   BCF ICSPDAT_in
   BCF ICSPDAT_out
   
   BCF tris_ICSPCLK        // pin A3 set as output, why was it initially set as input ?
   BCF ICSPCLK_in
   BCF ICSPCLK_out
   
   BSF tris_AUX            // pin A4 set as input
   BCF AUX
   
   BCF MCLR_TGT
   BCF tris_MCLR_TGT       // A5 Set as output
   
   BCF Vdd_TGT_N           // initialize half-bridge N-gate off
   BCF tris_Vdd_TGT_N
   
   BSF Vdd_TGT_P           // initialize half-bridge P-gate off
   BCF tris_Vdd_TGT_P
   
   BSF tris_PROG_SWITCH    // B5 input
   BSF PROG_SWITCH_pin     // initialize to 1
   BCF RBPU                // PORTB pull-ups are enabled by individual port latch value, DS page 102
   
   BCF Vpp_ON              // Initialize Vpp to off
   BCF tris_Vpp_ON         // B2 set as output
   
   BCF BUSY_LED            
   BCF tris_BUSY_LED       // BUSY_LED pin set as output
   
   BCF Vpp_PUMP            
   BCF tris_Vpp_PUMP       // C1 output (CCP2)
   
   BCF Vdd_TGT_ADJ
   BCF tris_Vdd_TGT_ADJ    // C2 output (CCP1)
   
   MOVLW 0x08
   MOVWF T0CON             //Timer0 off, 16-bit timer, internal clock, prescaler not assigned
   
   //Timer1 is used by VddVpp voltage monitoring interrupt or UART RX.
   //configure Timer2 (used by CCP1 and CCP2)
   
   MOVLW 0x04
   MOVWF T2CON             //1:1 Postscale, 1:1 Prescale, Timer2 on
   
   MOVLW PWM_150kHz        // PWM freq = 150kHz
   MOVWF PR2               //Timer2 Period Register (sets PWM Period for CCP1 and 2)
   
   MOVLW 0x0C              
   MOVWF CCP1CON           // PWM mode, datasheet page 151
   
   MOVLW Vdd_3V3            
   MOVWF CCPR1L
   
   // initialize CCP2 for VPP 
   //Maybe add later
   
   MOVLW 0x07              
   MOVWF CMCON          // Comparators off
   
   CLRF CVRCON          // Voltage Reference off
   
   // Set up Interrupts
    BSF PEIE         //enable Peripheral Interrupt Enable
    BSF GIE          //enable global interrupts
   
    // Start voltage monitoring
    //ppVddADCTmr1_Start();
    
    BSF PEIE         //Enable Peripheral interrupts 
    BSF GIE          //Enable global interrupts
   #ENDASM
   VoltageCalibration.adc_calfactor = 0x0100;  // Set default values. 
   VoltageCalibration.vdd_offset = 0x00;
   VoltageCalibration.vdd_calfactor = 0x80;
}

void Process_Input ()
{
/*
   #ASM 
      BSF BUSY_LED
   #ENDASM*/
   i = 1;   //Initialize index
   usb_get_packet(1, DATAin, 64);
   //usb_flush_out(1, USB_DTS_TOGGLE);
   delay_ms(1);
   unsigned int8 packet_length = DATAin[0];
   unsigned int8 offset;

   while (i <= packet_length)
   {
      offset = DATAin[i];
      if (offset < 0x01) break; //unknown instruction
      
      offset -= 0x01;
      offset *= 2;
      offset += 8;
      
      #ASM
         MOVF     PCL, W  //Save current PCL value in Wreg, by reading PCL, PCH and PCU will be loaded into PCLATH and PCLATU 
         ADDWF    offset, W
         BTFSC    C
         INCF     PCLATH
         MOVWF    PCL
         BRA      getVersionLbl
         BRA      toggleLEDLbl
         BRA      setVDDLbl
         BRA      setVPPLbl
         BRA      readVoltagesLbl
         BRA      runROMScriptLbl
         //BRA      downloadScrptArgsLbl
         BRA      CLEAR_DOWN_BUFF_LBL
         BRA      WRITE_DOWN_BUFF_LBL
         BRA      CLEAR_UP_BUFF_LBL
         BRA      UPLOAD_LBL
      #ENDASM 
      
getVersionLbl:
      get_version_number();
      break;
      
toggleLEDLbl:
      #ASM
         BTG BUSY_LED
      #ENDASM
      break;
      
setVDDLbl:
      /*
       * DATAin[i+1] = CCPL
       * DATAin[i+2] = CCPH
       * DATAin[i+3] = VDDLim
      */
      // CCPH:CCPL = ((Vdd * 32) + 10.5) << 6, << 6 because CCP1 (holds the duty cycle, resolution is 10 bits) and is left justified, the 2 LSB bits are located in CCP1CON.
      // Duty_cycle = vdd * 32+ 10.5
      cal_and_set_ccp (DATAin[i+2], DATAin[i+1]);
      VddVppLevels.VddThreshold = cal_threshold_byte (DATAin[i+3]);
      i += 4;
      continue;
      
setVPPLbl:
      /*
       * DATAin[i+1] = CCPR2L, this is the duty cycle, generally = 0x40;
       * DATAin[i+2] = VPPADC = Vpp * 18.61          Vpp is the desired voltage.
       * DATAin[i+3] = VPPlim = Vfault * 18.61 
      */
      Vpp_PWM.CCPRSetPoint = DATAin[i+1];
      Vpp_PWM.UppperLimit = cal_threshold_byte(DATAin[i+2])+1; //VPP upper limit = VPP + 1
      Vpp_PWM.LowerLimit = Vpp_PWM.UppperLimit - 2;        //VPP lower limit = VPP - 1
      VddVppLevels.VppThreshold = cal_threshold_byte(DATAin[i+3]); //calibrate VPPLim 
      i += 4;
      continue;
      
readVoltagesLbl:
      send_voltages ();
      i++;
      continue;
      
runROMScriptLbl:
      /*
       * DATAin[i+1] = Script's length
       * DATAin[i+2] = Least significant byte of the script's address
       * DATAin[i+3] = Most significant byte of the script's address
      */
      unsigned int8 *scriptBuffer = malloc (DATAin[i+1]);
      unsigned int16 address =  ((DATAin[i+3] * 0x100) + DATAin[i+2]);
      read_program_memory(address, scriptBuffer, DATAin[i+1]); 
      executeScript(DATAin[i+1], scriptBuffer);
      free(scriptBuffer);
      i += 4;
      continue;
      
//downloadScrptArgsLbl:
   //downloadScriptArgs();
   //i++;
   //continue;

CLEAR_DOWN_BUFF_LBL: 
      DIB_mngnt.rd_idx = 0;
      DIB_mngnt.wr_idx = 0;
      DIB_mngnt.nbr_bytes = 0;
      i++;
      continue;

WRITE_DOWN_BUFF_LBL:
      i++;
      write_down_buff();
      continue;

CLEAR_UP_BUFF_LBL:
      DOB_mngnt.rd_idx = 0;
      DOB_mngnt.wr_idx = 0;
      DOB_mngnt.nbr_bytes = 0;
      i++;
      continue;
      
UPLOAD_LBL:
      send_data_usb();
      i++;
      continue;
   }  
   /*
   #ASM
      BCF BUSY_LED
   #ENDASM*/
}

void get_version_number (void)
{
   /*
   unsigned int8 *DATAout  = malloc(4);
   *DATAout++ = 4;  //length of data to be sent, including this byte
   *DATAout++ = 0;
   *DATAout++ = 0;
   *DATAout = 1;
   usb_put_packet(1, (DATAout-3), 64, USB_DTS_TOGGLE);
   free(DATAout);
   */
   
   const char version[] = __DATE__;
   
   data_out [0] = 3;  //length of data to be sent, this byte not included
   data_out [1] = 0;
   data_out [2] = 2;    //month
   data_out [3] = ((version[0] - 48) * 16)+ (version[1] - 48); // substract 48 to convert from string to int
   usb_put_packet(1, data_out, 64, USB_DTS_TOGGLE);
}

//Used in setVDD
void cal_and_set_ccp (unsigned int8 ccph, unsigned int8 ccpl)
{
   signed int16 ccp1 = (ccph * 0x100) + ccpl; //ccp1 = ccph:ccpl
   unsigned int8 tempCal;
   ccp1 >>= 6; //
   ccp1 += VoltageCalibration.vdd_offset;
   ccp1 *= VoltageCalibration.vdd_calfactor;     //default is 0x80 = 0b10000000
   ccp1 >>= 1;                                   //shift by one to get the original >> 6 after multiplying by 0x80
   tempCal = (unsigned int8) (ccp1 >> 8);
   #ASM 
   MOVLW tempCal
   MOVWF CCPR1L
   #ENDASM
   
   //The following is to place the lower 2 bits of the duty cycle resolution in bits 4 and 5 of CCP1CON
   CCP1 &= 0xFF;
   tempCal = (unsigned int8) (CCP1 >> 2);

   CCP1CON = (CCP1CON & 0xCF) | tempCal;
   /*
   #ASM 
   MOVLW 0xCF
   ANDWF CCP1CON,W
   IORLW tempCal
   MOVWF CCP1CON
   #ENDASM
   */
}

unsigned int8 cal_threshold_byte(unsigned int8 voltageVal)
{
    unsigned int8 inverse_cal = 0x0200 - VoltageCalibration.adc_calfactor; //adc_calfactor by default is 0x0100 so, 0x0200 - adc_calfactor is the same as 1 / adc_calfactor 
    inverse_cal *= voltageVal;
    inverse_cal >>= 8;

    return (unsigned int8) inverse_cal;
} //See CalADCWord(unsigned int rawValue)

//TODO: create a function to store cal and offset values in eeprom and a function to read them

//Read VDD and VPP voltages, used to detect self-powered targets 
void send_voltages (void)
{
   unsigned int16 adc_result;
   unsigned int8 *DATAout = malloc(5);
   *DATAout++ = 5;   //Length of data to be sent
   adc_vpp_vdd_control (0); //Stop ADC, VPP and VDD
   getADC (0x04); //CH1_VDD
   adc_result = (ADRESH * 0x100) + ADRESL;
   adc_result = calADCWord(adc_result);
   *DATAout++ = (unsigned int8) adc_result;
   *DATAout++ = (unsigned int8) (adc_result >> 8);
   
   getADC (0x00); //CH0_VPP
   adc_result = (ADRESH * 0x100) + ADRESL;
   adc_result = calADCWord(adc_result);
   *DATAout++ = (unsigned int8) adc_result;
   *DATAout = (unsigned int8) (adc_result >> 8);
   
   usb_put_packet(1, (DATAout-4), 64, USB_DTS_TOGGLE);
   free(DATAout);
   adc_vpp_vdd_control (1); //Start ADC, VPP and VDD
}

void adc_vpp_vdd_control (int1 state)
{
   if (state)
   {//Activate modules
      VddVppLevels.VddErrCount = 0;
      VddVppLevels.VppErrCount = 0;
      #ASM
         MOVLW 0x80
         MOVWF T1CON            // Rd16 1:1 prescale off Fosc/4
         MOVLW 0xFA
         MOVWF TMR1H            //// 65536-1480 = about 125us
         MOVLW 0x38
         MOVWF TMR1L
         
         BCF   TMR1IF           // clear int flag
         BSF   TMR1IE           // enable int
         BSF   TMR1ON           // start timer
         
         BCF   ADIF  // clear A/D Converter Interrupt Flag
         BCF   ADIE  // Disable ADC int
         MOVLW 0x26
         MOVWF ADCON2           //ADCON2 setting for voltage monitoring
         MOVLW 0x05
         MOVWF ADCON0           // Set ADC channel for VDD_TGT_FB and turn on ADC (ADCON0)
         BSF   GO                // Start conversion.
      #ENDASM
   }
   else 
   { //Deactivate modules
      #ASM
         BCF   TMR1IE   // Disable Timer1 interrupt
         BCF   TMR1ON   // Stop Timer1
         
         CLRF  ADCON0   //Shut off ADC conversion in progress
         
         BCF   ADIF  // clear A/D Converter Interrupt Flag
         BCF   ADIE  // Disable ADC int
      #ENDASM
   }
}

void getADC (unsigned int8 channel)
{
   ADCON0 = (channel + 1);     // set channel. ADD 1 to enable A/D Converter (bit 0) page 261
   #ASM
   BSF GO                      // begin conversion
   #ENDASM   
   while ((ADCON0 | 0x02));       // wait while GO is still set
}

unsigned int16 calADCWord(unsigned int16 Val)
{

    unsigned int32 cal_value = Val;
    cal_value *= VoltageCalibration.adc_calfactor;
    cal_value >>= 8;
    if (cal_value > 0xFFFF)
        cal_value = 0xFFFF;

    return (unsigned int16) cal_value;
}

void write_down_buff(void)
{
   unsigned int8 len = DATAin[i++]; //get length of data
   
   if (len + DIB_mngnt.nbr_bytes > 255) return;  
   
   for (unsigned int8 k = 0; k < len; k++)
   {
      DATA_In_Buffer[DIB_mngnt.wr_idx++] = DATAin[i++];
      //if (DIB_mngnt.wr_idx > 255)       //just let DIB_mngnt.wr_idx overflow 
      //   DIB_mngnt.wr_idx = 0;
         
      DIB_mngnt.nbr_bytes++;
   }
   
}


void send_data_usb(void)
{
   unsigned int8 len = DOB_mngnt.nbr_bytes; //get number of bytes in DATA_Out_Buffer
   
   len = len < 63 ? len : 63; //first byte in usb report will be used to store length, the other 63 used for data
   data_out[0] = len;
   for (unsigned int8 m = 1; m <= len; m++)
   {
      data_out[m] = data_out_buffer[DOB_mngnt.rd_idx++];
      if (DOB_mngnt.rd_idx > 127)
            DOB_mngnt.rd_idx = 0;
   }
   
   DOB_mngnt.nbr_bytes -= len;
   usb_put_packet(1, data_out, len+1, USB_DTS_TOGGLE);
}

/*
void downloadScriptArgs (void)
{
   unsigned int8 len = DATAin[++i];
   for (unsigned int8 j = 0; j < len; j++)
   {
      scrpt_args[j] = DATAin[++i];           //Copy the arguments from USB packet to scrpt_args buffer 
   }
   scrpt_rd_idx = 0;
}

*/





void executeScript(unsigned int8 scrpt_len, unsigned int8 *scriptLocation)
{
   unsigned int8 si = 0; //initialize script index to 0
   unsigned int8 offset, loop_buff_idx, temp;
   int1 first_iteration_LB = 1; //used by LOOPBUFFER cmd
   int1 first_iteration_L = 1; //Used by LOOP cmd
   unsigned int16 nbr_iterations, loop_count, loop_idx;
   unsigned int8 *SFR_ptr; //used by the WRITE_SFR and READ_SFR commands
   
   #ASM
      BCF INT0IE //Disable Timer0 interrupt
      MOVLW 0x07
      MOVWF T0CON //16-bit timer, 1:256 prescale
   #ENDASM
   
   if (scrpt_len == 0) return; 
   while (si < scrpt_len)
   {
      offset = *(scriptLocation + si); 
      offset -= 0xD5;  // Consider 0xD5 to be the minimum for now
      offset *= 2;     
      offset += 8;     
      #ASM
         MOVF     PCL, W  //Save current PCL value in Wreg, by reading PCL, PCH and PCU will be loaded into PCLATH and PCLATU 
         ADDWF    offset, W
         BTFSC    C
         INCF     PCLATH
         MOVWF    PCL
         BRA      READ_N_BITS_LBL  //Read N bits from target and store them in DATA_Out_Buffer, (May not be used)
         BRA      READ_BYTE_LBL
         BRA      VISI24_LBL
         BRA      NOP24_LBL
         BRA      COREINST24_LBL
         BRA      COREINST18_LBL
         BRA      POP_DOWNLOAD_BUFFER_LBL
         BRA      READ_ICSP_STATES_LBL
         BRA      LOOPBUFFERLbl
         BRA      WRITE_SFRLbl
         BRA      READ_SFRLbl
         BRA      EXIT_SCRIPTLbl 
         BRA      GOTO_IDXLbl
         BRA      IF_GT_GOTOLbl  
         BRA      IF_EQ_GOTOLbl
         BRA      SHORT_DELAYLbl
         BRA      LONG_DELAYLbl
         BRA      LOOPLbl
         //BRA      SET_ICSP_RATELbl      //Used for HCS encoders, not MCUs
         BRA      SHIFT_BITS_IN_LBL
         BRA      SHIFT_BITS_IN_BUFFER_LBL
         BRA      SHIFT_BITS_OUT_BUFFER_LBL
         BRA      SHIFT_BITS_OUT_LBL
         BRA      SHIFT_BYTE_IN_LBL
         BRA      SHIFT_BYTE_IN_BUFFER_LBL
         BRA      SHIFT_BYTE_OUT_BUFFER_LBL
         BRA      SHIFT_BYTE_OUT_LBL
         BRA      SET_ICSP_PINS_LBL
         BRA      MCLR_TGT_GND_OFF_LBL
         BRA      MCLR_TGT_GND_ON_LBL
         BRA      VPP_PWM_OFF_LBL
         BRA      VPP_PWM_ON_LBL
         BRA      VPP_ON_LBL
         BRA      VPP_OFF_LBL
         BRA      VDD_GND_ON_LBL
         BRA      VDD_GND_OFF_LBL
         BRA      VDD_ON_LBL
         BRA      VDD_OFF_LBL
      #ENDASM 
READ_N_BITS_LBL:
      write_upload_buff(read_n_bits_24(*(scriptLocation + ++si)));//WriteUploadBuffer(readN_Bits(*(scriptLocation + si + 1)));
      si++;
      continue;
   
READ_BYTE_LBL:
      write_upload_buff(read_n_bits_24(8));
      si++;
      continue;

VISI24_LBL:
      ShiftBitsOutICSP(1, 4);
      ShiftBitsOutICSP(0, 8);
      write_upload_buff(read_n_bits_24(8));
      write_upload_buff(read_n_bits_24(8));
      si++;
      continue;
   
NOP24_LBL:
      ShiftBitsOutICSP(0, 8);
      ShiftBitsOutICSP(0, 8);
      ShiftBitsOutICSP(0, 8);
      ShiftBitsOutICSP(0, 8);
      si++;
      continue;
   
COREINST24_LBL:
      ShiftBitsOutICSP(0, 4);
      ShiftBitsOutICSP(*(scriptLocation + ++si), 8);
      ShiftBitsOutICSP(*(scriptLocation + ++si), 8);
      ShiftBitsOutICSP(*(scriptLocation + ++si), 8);
      si++;
      continue;

COREINST18_LBL:
      ShiftBitsOutICSP(0, 4);
      ShiftBitsOutICSP(*(scriptLocation + ++si), 8);
      ShiftBitsOutICSP(*(scriptLocation + ++si), 8);
      si++;
      continue;
   
POP_DOWNLOAD_BUFFER_LBL:
      pop_down_buff ();
      si++;
      continue;
   
readICSP_StatesLbl:
      write_upload_buff(getICSP_States());
      si++;
      continue;
   
LOOPBUFFERLbl:  //will loop through a number of script commands, argument is the number if bytes to loop through 
      if (!first_iteration_LB)
      {
         nbr_iterations--;
         if (nbr_iterations == 0)   //no iterations 
         {
            first_iteration_LB = 1; //number of iterations endded for the current run 
            si ++;
            continue;
         }
         si = first_iteration_LB;   //Still iterating
         continue;
      }
      loop_buff_idx = si - *(scriptLocation + ++si); //always loops to the instruction before it, except in the script n 255 in the original Firmware
      //scrpt_rd_idx -= 2;      //the instruction before LOOPBUFFER has 2 args
      nbr_iterations = (unsigned int16) pop_down_buff ();   //low byte
      nbr_iterations += (256  *  pop_down_buff ());         //upper byte
      if (nbr_iterations == 0)   //no iterations 
      {
         si++; //advance to next command 
         continue;
      }
      first_iteration_LB = 0;
      si = loop_buff_idx;  
      continue;
      
WRITE_SFRLbl:
      SFR_ptr = (unsigned int8 *) 0x0F00 + *(scriptLocation + ++si);
      *SFR_ptr = *(scriptLocation + ++si);
      si++;
      continue;

READ_SFRLbl:
      SFR_ptr = (unsigned int8 *) 0x0F00 + *(scriptLocation + ++si);
      write_upload_buff(*SFR_ptr);
      si++;
      continue;
      
EXIT_SCRIPTLbl:
      si = scrpt_len;
      continue;
      
GOTO_IDXLbl:
      si = *(scriptLocation + ++si);
      continue;
      
IF_GT_GOTOLbl: //if last loaded byte in DATA_Out_Buffer is greater than arg[1], execution will branch to offset specified by arg[2] 
      temp = DATA_Out_Buffer[DOB_mngnt.wr_idx - 1]; //get last byte written to DATA_Out_Buffer, - 1 because DOM_mngnt.wr_idx is always post-incremented, and points to the next location to be written
      if (temp > *(scriptLocation + ++si))
      {
         si += (signed int8) *(scriptLocation + ++si);
      }
      else 
      {
         si++;
      }
      continue;
      
IF_EQ_GOTOLbl: //if last loaded byte in DATA_Out_Buffer is equal than arg[1], execution will branch to offset specified by arg[2] 
      temp = DATA_Out_Buffer[DOB_mngnt.wr_idx - 1]; //get last byte written to DATA_Out_Buffer, - 1 because DOM_mngnt.wr_idx is always post-incremented, and points to the next location to be written
      if (temp == *(scriptLocation + ++si))
      {
         si += (signed int8) *(scriptLocation + ++si);
      }
      else 
      {
         si++;
      }
      continue;
      
SHORT_DELAYLbl:      //causes a delay of : duration * 21.3us, NOTE : 0 = 255
      delay_short (*(scriptLocation + ++si));
      si++;
      continue;
      
LONG_DELAYLbl:
      delay_long (*(scriptLocation + ++si));
      si++;
      continue;
      
LOOPLbl:
      if (!first_iteration_L)
      {
         loop_count--;
         if (loop_count == 0)
         {
            first_iteration_L = 1;
            si += 3; //LOOP command + 2 args
            continue;
         }
      }
      first_iteration_L = 0;
      loop_idx = si - *(scriptLocation + si + 1);
      loop_count = *(scriptLocation + si + 2);
      si = loop_idx;
      continue;
 
//SET_ICSP_RATELbl:
//      icsp_rate = *(scriptLocation + ++si);
//      si++;
//      continue;

SHIFT_BITS_IN_LBL:
      shift_bits_in(*(scriptLocation + ++si));
      si++;
      continue;
      
SHIFT_BITS_IN_BUFFER_LBL:
      write_upload_buff(shift_bits_in(*(scriptLocation + ++si)));
      si++;
      continue;
      
SHIFT_BITS_OUT_BUFFER_LBL: //Shift bits located in DATA_In_Buffer out 
      shift_bits_out (pop_down_buff(), *(scriptLocation + ++si));
      si++;
      continue;
      
SHIFT_BITS_OUT_LBL:
      shift_bits_out (*(scriptLocation + si + 2), *(scriptLocation + si + 1));
      si += 3;
      continue;
      
SHIFT_BYTE_IN_LBL:
      shift_bits_in(8);
      si++;
      continue;
      
SHIFT_BYTE_IN_BUFFER_LBL:
      write_upload_buff (shift_bits_in(8));
      si++;
      continue;
      
SHIFT_BYTE_OUT_BUFFER_LBL:
      shift_bits_out (pop_down_buff(), 8);
      si++;
      continue;
      
SHIFT_BYTE_OUT_LBL:
      shift_bits_out (*(scriptLocation + ++si), 8);
      si++;
      continue;
      
SET_ICSP_PINS_LBL:
      icsp_pins_states = *(scriptLocation + ++si);
      set_icsp_pins(icsp_pins_states);
      si++;
      continue;
      
MCLR_TGT_GND_OFF_LBL:
      #ASM
         BCF   MCLR_TGT
      #ENDASM
      #ASM
         BSF   BUSY_LED  //Busy LED
      #ENDASM
      si++;
      continue;

MCLR_TGT_GND_ON_LBL:
      #ASM
         BSF   MCLR_TGT
      #ENDASM
      si++;
      continue;
      
VPP_PWM_OFF_LBL:
      CCP2CON = 0x00; //Turn off PWM, DS page 143
      Vpp_PUMP = 0;
      si++;
      continue;
      
VPP_PWM_ON_LBL:
      CCP2CON = 0x0C; //PWM mode, DS page 143
      si++;
      continue;
      
VPP_ON_LBL:
      #ASM
         BSF   Vpp_ON
         BCF   BUSY_LED  //Busy LED
      #ENDASM
      si++; 
      continue;
 
 VPP_OFF_LBL:
      #ASM
         BCF   Vpp_ON
      #ENDASM
      si++; 
      continue;
      
VDD_GND_ON_LBL:
      #ASM
         BSF   Vdd_TGT_N
      #ENDASM
      si++; 
      continue;
      
VDD_GND_OFF_LBL:
      #ASM
         BCF   Vdd_TGT_N
      #ENDASM
      si++; 
      continue;
 
VDD_ON_LBL:
      #ASM
         BCF   Vdd_TGT_P
      #ENDASM
      si++; 
      continue;
      
VDD_OFF_LBL:
      #ASM
         BSF   Vdd_TGT_P
      #ENDASM
      si++; 
      continue;
      
   } //end of while loop
}


/* 
 * FOR PIC24F
 * Reads N bits and copy them in the upload buffer 
 * **read_n_bits_24(n)**
*/
unsigned int8 read_n_bits_24(unsigned int8 numberOfBits)
{
   unsigned int8 bitsBuff = 0; //Bits are shifted in here 
   //unsigned int8 iteration = numberOfBits;
   #ASM
      BSF      tris_ICSPDAT  //Set PGD pin as input
      //MOVLW 0x01        //this will be used to set the bits 
   READBITSLOOP:
      BTFSC    ICSPDAT_in  //read PGD pin
      BSF      bitsBuff,0      //If PGD was high, set the corresponding bit starting from LSB
      BSF      ICSPCLK_out       //Clock rising edge
      //RLNCF    W,W               //Rotate W left, (no carry)
      NOP
      NOP
      NOP
      BCF      ICSPCLK_out    //Clock falling edge 
      NOP
      RRNCF    bitsBuff, f    //Rotate right (no carry)
      DECFSZ   numberOfBits, f
      BRA      READBITSLOOP
   #ENDASM
   return bitsBuff;
}


void write_upload_buff(unsigned int8 wrByte)
{
   if (DOB_mngnt.nbr_bytes > 127) 
   {
      return;
   }
   DATA_Out_Buffer[DOB_mngnt.wr_idx++] = wrByte;
   if (DOB_mngnt.wr_idx > 127)
      DOB_mngnt.wr_idx = 0;
   
   DOB_mngnt.nbr_bytes++;
}

/*
 * Note: ICSP pins must be set to outputs
 *
 *
*/
void shiftBitsOutICSP (unsigned int8 charToBeShifted, unsigned int8 numberOfBits)
{
   //unsigned int8 tempChar = charToBeShifted;
   
   
   #ASM
      BITSOUTLOOP:
         BTFSS    charToBeShifted,0
         BCF      ICSPDAT_out    //If LSB of charToBeShifted is 0, clear PGD pin
         BTFSC    charToBeShifted,0
         BCF      ICSPDAT_out
         NOP
         BSF      ICSPCLK_out    //Clock rising edge 
         NOP
         BCF      ICSPCLK_out
         RRNCF    charToBeShifted,f
         DECFSZ   numberOfBits
         BRA      BITSOUTLOOP
   #ENDASM
}

unsigned int8 getICSP_States(void)
{
   unsigned int8 state = 0;
   if (ICSPDAT_in == 1)    //ICSPDAT_in = PORTA.2
      state |= 0x02;
   if (ICSPCLK_in == 1)    //ICSPCLK_in = PORTA.3
      state |= 0x01;
      
   return state;
}

//Return a byte from the DATA_In_Buffer
unsigned int8 pop_down_buff (void)
{
   unsigned int8 popped; 
   if (DIB_mngnt.nbr_bytes == 0)
   {
      return 0;
   }
   popped = DATA_In_Buffer[DIB_mngnt.rd_idx++];
   DIB_mngnt.nbr_bytes--;
   if (DIB_mngnt.rd_idx > 255)
      DIB_mngnt.rd_idx = 0;
   
   return popped;
}

//Each Timer0's lower byte increment is 21.3 uS, there's a delay of 12 uS between script commands, it is ignored here
void delay_short (unsigned int8 duration)
{
   #ASM
      BCF   TMR0IF   //Clear timer0 interrupt flag
      MOVLW    0xFF     //So that the timer will overflow when TMR0L does
      MOVWF    TMR0H
   #ENDASM
   TMR0L = 0 - duration;
   TMR0ON = 1; //start Timer0, DS page 127
   while (TMR0IF == 0); //Wait for overflow flag to be set
   TMR0ON = 0; //Stop Timer0
   
}

//Each Timer0's upper byte increment is 5.46mS
void delay_long (unsigned int8 duration)
{
   TMR0IF = 0;
   TMR0H = 0 - duration;
   TMR0L = 0;
   TMR0ON = 1; //Start Timer0
   while (TMR0IF == 0); //Wait for overflow flag to be set
   TMR0ON = 0; //Stop Timer0
}

unsigned int8 shift_bits_in (unsigned int8 number_of_bits)
{
   
   unsigned int8 bits_buff = 0; //Bits are shifted in here 
   #ASM
      BSF      tris_ICSPDAT  //Set PGD pin as input
   READBITSLOOP:
      BSF      ICSPCLK_out       //Clock rising edge
      NOP
      NOP
      NOP
      BTFSC    ICSPDAT_in  //read PGD pin
      BSF      bits_buff,0      //If PGD was high, set the corresponding bit starting from LSB
      BCF      ICSPCLK_out    //Clock falling edge 
      NOP
      RRNCF    bits_buff, f    //Rotate right (no carry)
      DECFSZ   number_of_bits, f
      BRA      READBITSLOOP
      BCF      tris_ICSPDAT //PGD set as output
   #ENDASM
   bits_buff >>= (8 - number_of_bits); //right justified
   return bits_buff;
}

void shift_bits_out (unsigned int8  outb, unsigned int8 number_of_bits)
{
   #ASM
      BCF   tris_ICSPDAT   //Make sure PGD pin is set as output
      WRITELOOP:
         BTFSS    outb,0
         BCF      ICSPDAT_out
         BTFSC    outb,0
         BSF      ICSPDAT_out
         NOP
         BSF      ICSPCLK_out //Clock rising edge
         NOP
         BCF      ICSPCLK_out  //Clock falling edge 
         RRNCF    outb
         DECFSZ   number_of_bits
         BRA      WRITELOOP
   #ENDASM
}

void set_icsp_pins(unsigned int8 state)
{
   ICSPCLK_out  = (state & 0x04) ? 1 : 0; //state[3] = Clock state
   ICSPDAT_out  = (state & 0x08) ? 1 : 0; //state[4] = Data state
   tris_ICSPCLK = (state & 0x01) ? 1 : 0; //state[0] = Clock direction
   tris_ICSPDAT = (state & 0x02) ? 1 : 0; //state[1] = Data direction
}









